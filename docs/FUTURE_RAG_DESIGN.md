# Antigravity Link v2.0: RAG Architecture Concept

## 1. 概要: 「記憶の壁」の突破
現在のシステム（No RAG）におけるGeminiのコンテキストウィンドウの限界（「記憶の壁」）を、RAG（Retrieval-Augmented Generation）によって突破する構想です。

### 現状 (No RAG) vs RAG導入後
| 特徴 | 現状 (No RAG) | RAG導入後 (v2.0) |
| :--- | :--- | :--- |
| **知識へのアクセス** | 教科書の丸暗記 (コンテキスト詰め込み) | カンニングペーパー (必要な部分だけ参照) |
| **限界** | 巨大なファイルを読み込むとメモリ/トークン制限に達する | 100万行、1億行のコードベースでも対応可能 |
| **処理フロー** | 全読み込み -> 回答 | 検索 -> 関連箇所のみ読み込み -> 回答 |

## 2. デスクトップ以上の「知能の拡張」
RAGは単なる検索ではなく、物理的なPCスペックを超えた知能の拡張を実現します。

1.  **記憶量の拡張**: 過去のコード資産、膨大なドキュメント、数千ファイルから瞬時に必要な情報を引き出す。「数千人のエンジニアの知識を持つベテラン社員」をPC内に再現するイメージ。
2.  **文脈の拡張**: プロジェクトを跨いだ知識（過去の類似実装など）の活用が可能になる。

## 3. 実装アプローチ (Technical Stack)
現在の Node.js + Python 環境で実装可能です。

-   **Vector DB**: ChromaDB, FAISS, HNSWLib (ローカル動作/サーバーレス)
-   **Embeddings**: Gemini `text-embedding-004` 等を使用し、コードをベクトル（意味の数値化）へ変換。
-   **Architecture**:
    -   **Knowledge Base**: 全コード・ドキュメントを格納する「専用図書館」。
    -   **Retriever (司書)**: ユーザーの問い合わせに関連する情報を検索。
    -   **Generator (LLM)**: 検索結果に基づき回答を生成。

## 4. 課題: データの「鮮度」 (Data Freshness)
コードベースRAG特有の最大の技術的課題です。

-   **問題**: コードは頻繁に書き換えられる。ファイル更新直後にRAGが古い情報を返すと、AIは混乱する。
-   **解決策**: ファイルシステムの監視 (`fs.watch` 等) と連動し、ファイル更新を検知した瞬間にベクトルインデックスを部分更新するリアルタイムパイプラインが不可欠。

## 5. ベクトル化のイメージ
AIは「認証」と「Login」の文字面が異なっても、ベクトル空間（多次元の地図）上で位置が近いことを理解し、概念的な検索を可能にする。

---
> *This document is based on the architectural vision for Antigravity Link v2.0.*
